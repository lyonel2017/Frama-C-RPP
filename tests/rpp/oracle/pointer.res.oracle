[kernel] Parsing tests/rpp/pointer.c (with preprocessing)
[kernel:typing:int-conversion] tests/rpp/pointer.c:31: Warning: 
  Conversion from a pointer to an integer without an explicit cast
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Relational_axiome_1 {
  predicate f_acsl_1(int *x, int return_variable_relational) ;
  
  lemma Relational_lemma_1{L}:
    ∀ int *x1, int *x2, int return_variable_relational_2,
        int return_variable_relational_1;
      f_acsl_1(x2, return_variable_relational_2) ⇒
      f_acsl_1(x1, return_variable_relational_1) ⇒
      x1 ≡ x2 ⇒
      return_variable_relational_1 ≡ return_variable_relational_2;
  
  }
 */
/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_1:
      ensures f_acsl_1(\old(x), \result);
 */
int f(int *x)
{
  int __retres;
  __retres = *x;
  return __retres;
}

int *y;
/*@
axiomatic Relational_axiome_2 {
  predicate h_acsl_2{pre}(int *y, int return_variable_relational) 
    reads \at(*y,pre);
  
  lemma Relational_lemma_2{pre_id4, pre_id3}:
    ∀ int *y_id4, int return_variable_relational_4, int *y_id3,
        int return_variable_relational_3;
      \separated(y_id4, y_id3) ⇒
      h_acsl_2{pre_id4}(y_id4, return_variable_relational_4) ⇒
      h_acsl_2{pre_id3}(y_id3, return_variable_relational_3) ⇒
      \at(*y_id3,pre_id3) ≡ \at(*y_id4,pre_id4) ⇒
      return_variable_relational_3 ≡ return_variable_relational_4;
  
  }

*/
/*@ assigns \result;
    assigns \result \from *y;
    
    behavior Relational_behavior_2:
      ensures h_acsl_2{Pre}(y, \result);
 */
int h(void)
{
  int __retres;
  __retres = *y;
  return __retres;
}

/*@
axiomatic Relational_axiome_3 {
  predicate l_acsl_3(int *y_pre, int return_variable_relational) ;
  
  lemma Relational_lemma_3{L}:
    ∀ int *y_id6_pre, int return_variable_relational_6, int *y_id5_pre,
        int return_variable_relational_5;
      l_acsl_3(y_id6_pre, return_variable_relational_6) ⇒
      l_acsl_3(y_id5_pre, return_variable_relational_5) ⇒
      y_id5_pre ≡ y_id6_pre ⇒
      return_variable_relational_5 ≡ return_variable_relational_6;
  
  }

*/
/*@ assigns \result;
    assigns \result \from y;
    
    behavior Relational_behavior_3:
      ensures l_acsl_3(\at(y,Pre), \result);
 */
int l(void)
{
  int __retres;
  __retres = (int)y;
  return __retres;
}

void relational_wrapper_1(int *x1, int *x2)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  {
    int __retres_1;
    __retres_1 = *x1;
    return_variable_relational_1 = __retres_1;
  }
  {
    int __retres_2;
    __retres_2 = *x2;
    return_variable_relational_2 = __retres_2;
  }
  /*@ check
      Rpp:
        x1 ≡ x2 ⇒
        return_variable_relational_1 ≡ return_variable_relational_2;
  */
  return;
}

int *y_id3_2;

int *y_id4_2;

/*@ requires \separated(y_id4_2, y_id3_2); */
void relational_wrapper_2(void)
{
  int return_variable_relational_3;
  int return_variable_relational_4;
  {
    int __retres_3;
    __retres_3 = *y_id3_2;
    return_variable_relational_3 = __retres_3;
  }
  {
    int __retres_4;
    __retres_4 = *y_id4_2;
    return_variable_relational_4 = __retres_4;
  }
  /*@ check
      Rpp:
        \at(*y_id3_2,Pre) ≡ \at(*y_id4_2,Pre) ⇒
        return_variable_relational_3 ≡ return_variable_relational_4;
  */
  return;
}

int *y_id5_3;

int *y_id6_3;

void relational_wrapper_3(void)
{
  int return_variable_relational_5;
  int return_variable_relational_6;
  {
    int __retres_5;
    __retres_5 = (int)y_id5_3;
    return_variable_relational_5 = __retres_5;
  }
  {
    int __retres_6;
    __retres_6 = (int)y_id6_3;
    return_variable_relational_6 = __retres_6;
  }
  /*@ check
      Rpp:
        \at(y_id5_3,Pre) ≡ \at(y_id6_3,Pre) ⇒
        return_variable_relational_5 ≡ return_variable_relational_6;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
