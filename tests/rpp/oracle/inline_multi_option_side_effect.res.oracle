[kernel] Parsing tests/rpp/inline_multi_option_side_effect.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
int x;
int y;
/*@
axiomatic Relational_axiome_1 {
  predicate f1_acsl_1
    (int x_pre, int x_post, int return_variable_relational) ;
  
  predicate g_acsl_1
    (int y_pre, int x_pre, int y_post, int x_post,
    int return_variable_relational) ;
  
  predicate f2_acsl_1
    (int y_pre, int y_post, int return_variable_relational) ;
  
  lemma Relational_lemma_1{L}:
    ∀ int x_id3_pre, int y_id3_pre, int x_id3_post, int y_id3_post,
        int return_variable_relational_3, int y_id2_pre, int y_id2_post,
        int return_variable_relational_2, int x_id1_pre, int x_id1_post,
        int return_variable_relational_1;
      g_acsl_1(y_id3_pre, x_id3_pre, y_id3_post, x_id3_post,
              return_variable_relational_3) ⇒
      f2_acsl_1(y_id2_pre, y_id2_post, return_variable_relational_2) ⇒
      f1_acsl_1(x_id1_pre, x_id1_post, return_variable_relational_1) ⇒
      x_id1_pre ≡ x_id3_pre ∧ y_id2_pre ≡ y_id3_pre ∧
      x_id1_pre ≡ y_id2_pre ⇒
      return_variable_relational_1 < return_variable_relational_2 <
      return_variable_relational_3;
  
  }
 */
/*@ requires x > 0;
    ensures x > 0;
    assigns x;
    assigns x \from x;
    
    behavior Relational_behavior_1:
      ensures f1_acsl_1(\at(x,Pre), \at(x,Post), \result);
 */
int f1(void)
{
  x ++;
  return x;
}

/*@ requires y > 0;
    assigns y;
    assigns y \from y;
    
    behavior Relational_behavior_1:
      ensures f2_acsl_1(\at(y,Pre), \at(y,Post), \result);
 */
int f2(void)
{
  y = 2 + y;
  return y;
}

/*@ requires x > 0;
    requires y > 0;
    assigns y, x;
    assigns y \from y;
    assigns x \from x;
    
    behavior Relational_behavior_1:
      ensures
        g_acsl_1(\at(y,Pre), \at(x,Pre), \at(y,Post), \at(x,Post), \result);
 */
int g(void)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  tmp = f1();
  tmp_0 = f2();
  tmp_1 = f1();
  __retres = (tmp + tmp_0) + tmp_1;
  return __retres;
}

int x_id1_1;

int y_id2_1;

int x_id3_1;

int y_id3_1;

/*@ requires x_id3_1 > 0;
    requires y_id3_1 > 0;
    requires y_id2_1 > 0;
    requires x_id1_1 > 0;
 */
void relational_wrapper_1(void)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  int return_variable_relational_3;
  /*@ assert Rpp: x_id1_1 > 0; */
  x_id1_1 ++;
  return_variable_relational_1 = x_id1_1;
  /*@ assert Rpp: y_id2_1 > 0; */
  y_id2_1 = 2 + y_id2_1;
  return_variable_relational_2 = y_id2_1;
  {
    int __retres_3;
    int tmp_3;
    int tmp_0_3;
    int tmp_1_3;
    /*@ assert Rpp: x_id3_1 > 0; */
    /*@ assert Rpp: y_id3_1 > 0; */
    {
      /*@ assert Rpp: x_id3_1 > 0; */
      {
        x_id3_1 ++;
        tmp_3 = x_id3_1;
      }
      /*@ assert Rpp: y_id3_1 > 0; */
      {
        y_id3_1 = 2 + y_id3_1;
        tmp_0_3 = y_id3_1;
      }
      /*@ assert Rpp: x_id3_1 > 0; */
      {
        x_id3_1 ++;
        tmp_1_3 = x_id3_1;
      }
    }
    __retres_3 = (tmp_3 + tmp_0_3) + tmp_1_3;
    return_variable_relational_3 = __retres_3;
  }
  /*@ assert
      Rpp:
        \at(x_id1_1,Pre) ≡ \at(x_id3_1,Pre) ∧
        \at(y_id2_1,Pre) ≡ \at(y_id3_1,Pre) ∧
        \at(x_id1_1,Pre) ≡ \at(y_id2_1,Pre) ⇒
        return_variable_relational_1 < return_variable_relational_2 <
        return_variable_relational_3;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
