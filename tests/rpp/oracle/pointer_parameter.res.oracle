[kernel] Parsing tests/rpp/pointer_parameter.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Sum {
  logic ℤ sum{L}(int *t, ℤ i, ℤ j) 
    reads i, j, t, *(t + (..));
  
  axiom sum1{L}: ∀ int *t, ℤ i, ℤ j; i ≥ j ⇒ sum(t, i, j) ≡ 0;
  
  axiom sum2{L}:
    ∀ int *t, ℤ i, ℤ j;
      i ≤ j ⇒ sum(t, i, j + 1) ≡ sum(t, i, j) + *(t + j);
  
  }
 */
/*@
lemma sum3{L}:
  ∀ int *t, ℤ i, ℤ j, ℤ k;
    i ≤ j ≤ k ⇒ sum(t, i, k) ≡ sum(t, i, j) + sum(t, j, k);
 */
/*@
lemma sum_footprint{L}:
  ∀ int *t1, int *t2, ℤ i, ℤ j;
    (∀ ℤ k; i ≤ k < j ⇒ *(t1 + k) ≡ *(t2 + k)) ⇒
    sum(t1, i, j) ≡ sum(t2, i, j);
 */
/*@
axiomatic Relational_axiome_1 {
  predicate f_acsl_1{pre}(int n, int *t, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre);
  
  lemma Relational_lemma_1{pre_id2, pre_id1}:
    ∀ int n, int *t1, int *t2, int return_variable_relational_2,
        int return_variable_relational_1;
      \separated(t2 + (0 .. n), t1 + (0 .. n)) ⇒
      f_acsl_1{pre_id2}(n, t2, return_variable_relational_2) ⇒
      f_acsl_1{pre_id1}(n, t1, return_variable_relational_1) ⇒
      (∀ int k;
         0 ≤ k < n ⇒ \at(*(t1 + k),pre_id1) ≡ \at(*(t2 + k),pre_id2)) ⇒
      return_variable_relational_1 ≡
      return_variable_relational_2 + \at(*(t2 + (n - 1)),pre_id1);
  
  }
 */
/*@ requires n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
    
    behavior Relational_behavior_1:
      ensures f_acsl_1{Pre}(\old(n), \old(t), \result);
 */
int f(int n, int *t)
{
  int i = 0;
  int s = 0;
  i = 0;
  /*@ loop invariant 0 ≤ i ≤ n ∧ s ≡ sum(t, 0, i);
      loop assigns s, i;
      loop variant n - i;
  */
  while (i < n) {
    s += *(t + i);
    i ++;
  }
  return s;
}

/*@
axiomatic Relational_axiome_2 {
  predicate g_acsl_2{pre}(int n, int *t, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre);
  
  lemma Relational_lemma_2{pre_id4, pre_id3}:
    ∀ int n, int *t1, int *t2, int return_variable_relational_4,
        int return_variable_relational_3;
      \separated(t2 + (0 .. n), t1 + (0 .. n)) ⇒
      g_acsl_2{pre_id4}(n, t2, return_variable_relational_4) ⇒
      g_acsl_2{pre_id3}(n, t1, return_variable_relational_3) ⇒
      (∀ int k;
         0 ≤ k < n ⇒ \at(*(t1 + k),pre_id3) ≡ \at(*(t2 + k),pre_id4)) ⇒
      return_variable_relational_3 ≡
      return_variable_relational_4 + \at(*(t2 + (n - 1)),pre_id4);
  
  }

*/
/*@ requires n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
    
    behavior Relational_behavior_2:
      ensures g_acsl_2{Pre}(\old(n), \old(t), \result);
 */
int g(int n, int *t);

/*@
axiomatic Relational_axiome_3 {
  predicate k_acsl_3{pre}(int *t, int n, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre);
  
  lemma Relational_lemma_3{pre_id5}:
    ∀ int *t1, int return_variable_relational_5;
      k_acsl_3(t1, *(t1 + 9), return_variable_relational_5) ⇒
      return_variable_relational_5 ≡ \at(*(t1 + 10),pre_id5);
  
  }

*/
/*@ requires 10 > n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
    
    behavior Relational_behavior_3:
      ensures k_acsl_3{Pre}(\old(t), \old(n), \result);
 */
int k(int *t, int n);

/*@
axiomatic Relational_axiome_4 {
  predicate p_acsl_4{pre}(int *t, int n, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre);
  
  lemma Relational_lemma_4{pre_id6}:
    ∀ int *t1, int return_variable_relational_6;
      p_acsl_4(t1, *(t1 + 9), return_variable_relational_6) ⇒
      return_variable_relational_6 ≡ \at(*(t1 + 10),pre_id6);
  
  }

*/
/*@ requires 10 > n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
    
    behavior Relational_behavior_4:
      ensures p_acsl_4{Pre}(\old(t), \old(n), \result);
 */
int p(int *t, int n)
{
  int __retres;
  __retres = *(t + n);
  return __retres;
}

/*@ requires 10 > n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
 */
int k_id5(int *t, int n);

/*@ requires n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
 */
int g_id4(int n, int *t);

/*@ requires n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
 */
int g_id3(int n, int *t);

/*@ requires n > 0;
    requires \valid(t + (0 .. n));
    assigns \result;
    assigns \result \from n, *(t + (0 .. n));
 */
int f_id2(int n, int *t);

/*@ requires \separated(t2 + (0 .. n), t1 + (0 .. n));
    requires n > 0;
    requires \valid(t2 + (0 .. n));
    requires n > 0;
    requires \valid(t1 + (0 .. n));
 */
void relational_wrapper_1(int n, int *t1, int *t2)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  {
    /*@ assert Rpp: n > 0; */
    /*@ assert Rpp: \valid(t1 + (0 .. n)); */
    int i_1 = 0;
    int s_1 = 0;
    i_1 = 0;
    /*@ loop invariant 0 ≤ i_1 ≤ n ∧ s_1 ≡ sum(t1, 0, i_1);
        loop assigns s_1, i_1;
        loop variant n - i_1;
    */
    while (i_1 < n) {
      s_1 += *(t1 + i_1);
      i_1 ++;
    }
    return_variable_relational_1 = s_1;
  }
  /*@ assert Rpp: n > 0; */
  /*@ assert Rpp: \valid(t2 + (0 .. n)); */
  return_variable_relational_2 = f_id2(n,t2);
  /*@ check
      Rpp:
        (∀ int k; 0 ≤ k < n ⇒ \at(*(t1 + k),Pre) ≡ \at(*(t2 + k),Pre)) ⇒
        return_variable_relational_1 ≡
        return_variable_relational_2 + \at(*(t2 + (n - 1)),Pre);
  */
  return;
}

/*@ requires \separated(t2 + (0 .. n), t1 + (0 .. n));
    requires n > 0;
    requires \valid(t2 + (0 .. n));
    requires n > 0;
    requires \valid(t1 + (0 .. n));
 */
void relational_wrapper_2(int n, int *t1, int *t2)
{
  int return_variable_relational_3;
  int return_variable_relational_4;
  /*@ assert Rpp: n > 0; */
  /*@ assert Rpp: \valid(t1 + (0 .. n)); */
  return_variable_relational_3 = g_id3(n,t1);
  /*@ assert Rpp: n > 0; */
  /*@ assert Rpp: \valid(t2 + (0 .. n)); */
  return_variable_relational_4 = g_id4(n,t2);
  /*@ check
      Rpp:
        (∀ int k; 0 ≤ k < n ⇒ \at(*(t1 + k),Pre) ≡ \at(*(t2 + k),Pre)) ⇒
        return_variable_relational_3 ≡
        return_variable_relational_4 + \at(*(t2 + (n - 1)),Pre);
  */
  return;
}

/*@ requires 10 > *(t1 + 9) > 0;
    requires \valid(t1 + (0 .. *(t1 + 9))); */
void relational_wrapper_3(int *t1)
{
  int aux_local_variable_1;
  int return_variable_relational_5;
  aux_local_variable_1 = *(t1 + 9);
  /*@ assert Rpp: 10 > aux_local_variable_1 > 0; */
  /*@ assert Rpp: \valid(t1 + (0 .. aux_local_variable_1)); */
  return_variable_relational_5 = k_id5(t1,aux_local_variable_1);
  /*@ check Rpp: return_variable_relational_5 ≡ \at(*(t1 + 10),Pre); */
  return;
}

/*@ requires 10 > *(t1 + 9) > 0;
    requires \valid(t1 + (0 .. *(t1 + 9))); */
void relational_wrapper_4(int *t1)
{
  int aux_local_variable_2;
  int return_variable_relational_6;
  aux_local_variable_2 = *(t1 + 9);
  {
    int __retres_6;
    /*@ assert Rpp: 10 > aux_local_variable_2 > 0; */
    /*@ assert Rpp: \valid(t1 + (0 .. aux_local_variable_2)); */
    __retres_6 = *(t1 + aux_local_variable_2);
    return_variable_relational_6 = __retres_6;
  }
  /*@ check Rpp: return_variable_relational_6 ≡ \at(*(t1 + 10),Pre); */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
