[kernel] Parsing tests/rpp/inline_option.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Relational_axiome_1 {
  logic int f1_acsl_pure_1(int x) ;
  
  lemma Relational_lemma_1{L}: ∀ int x1; f1_acsl_pure_1(x1) > 0;
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic int g_acsl_pure_2(int x) ;
  
  logic int f1_acsl_pure_2(int x) ;
  
  logic int f2_acsl_pure_2(int y) ;
  
  lemma Relational_lemma_2{L}:
    ∀ int x1; f1_acsl_pure_2(x1) < f2_acsl_pure_2(x1) < g_acsl_pure_2(x1);
  
  }
 */
/*@ requires x > 0;
    assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_1:
      ensures \result ≡ f1_acsl_pure_1(\old(x));
    
    behavior Relational_behavior_2:
      ensures \result ≡ f1_acsl_pure_2(\old(x));
 */
int f1(int x)
{
  int __retres;
  __retres = x + 1;
  return __retres;
}

/*@ requires x1 > 0; */
void relational_wrapper_1(int x1)
{
  int return_variable_relational_1;
  {
    int __retres_1;
    /*@ assert Rpp: x1 > 0; */
    __retres_1 = x1 + 1;
    return_variable_relational_1 = __retres_1;
  }
  /*@ assert Rpp: return_variable_relational_1 > 0; */
  return;
}

/*@ requires y > 0;
    assigns \result;
    assigns \result \from y;
    
    behavior Relational_behavior_2:
      ensures \result ≡ f2_acsl_pure_2(\old(y));
 */
int f2(int y)
{
  int __retres;
  __retres = 2 + y;
  return __retres;
}

/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_2:
      ensures \result ≡ g_acsl_pure_2(\old(x));
 */
int g(int x)
{
  int __retres;
  int tmp;
  int tmp_0;
  tmp = f1(x);
  tmp_0 = f2(x);
  __retres = tmp + tmp_0;
  return __retres;
}

int f1_aux_2(int x);

int f2_aux_2(int y);

/*@ requires x1 > 0;
    requires x1 > 0;
    requires x1 > 0; */
void relational_wrapper_2(int x1)
{
  int return_variable_relational_2;
  int return_variable_relational_3;
  int return_variable_relational_4;
  int return_variable_relational_5;
  /*@ assert Rpp: x1 > 0; */
  return_variable_relational_2 = f1_aux_2(x1);
  /*@ assert Rpp: x1 > 0; */
  return_variable_relational_3 = f2_aux_2(x1);
  /*@ assert Rpp: x1 > 0; */
  return_variable_relational_4 = f2_aux_2(x1);
  {
    int __retres_5;
    int tmp_5;
    int tmp_0_5;
    tmp_5 = f1_aux_2(x1);
    tmp_0_5 = f2_aux_2(x1);
    __retres_5 = tmp_5 + tmp_0_5;
    return_variable_relational_5 = __retres_5;
  }
  /*@ assert
      Rpp:
        return_variable_relational_2 < return_variable_relational_3 ∧
        return_variable_relational_4 < return_variable_relational_5;
  */
  return;
}

/*@
axiomatic Relational_axiome_4 {
  logic int fact_acsl_pure_4(int x) ;
  
  lemma Relational_lemma_4{L}:
    ∀ int x1;
      x1 > 1 ⇒
      fact_acsl_pure_4((int)(x1 + 1)) ≡ fact_acsl_pure_4(x1) * (x1 + 1);
  
  }
 */
/*@
axiomatic Relational_axiome_3 {
  logic int fact_acsl_pure_3(int x) ;
  
  lemma Relational_lemma_3{L}:
    ∀ int x1; x1 ≤ 1 ⇒ fact_acsl_pure_3(x1) ≡ 1;
  
  }

*/
/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_3:
      ensures \result ≡ fact_acsl_pure_3(\old(x));
    
    behavior Relational_behavior_4:
      ensures \result ≡ fact_acsl_pure_4(\old(x));
 */
int fact(int x)
{
  int __retres;
  if (x <= 1) {
    __retres = 1;
    goto return_label;
  }
  else {
    int tmp;
    tmp = fact(x - 1);
    ;
    __retres = x * tmp;
    goto return_label;
  }
  return_label: return __retres;
}

int fact_aux_3(int x);

void relational_wrapper_3(int x1)
{
  int return_variable_relational_6;
  {
    int __retres_6;
    if (x1 <= 1) {
      __retres_6 = 1;
      goto return_label_label_1;
    }
    else {
      int tmp_6;
      tmp_6 = fact_aux_3(x1 - 1);
      ;
      __retres_6 = x1 * tmp_6;
      goto return_label_label_1;
    }
    return_label_label_1: return_variable_relational_6 = __retres_6;
  }
  /*@ assert Rpp: x1 ≤ 1 ⇒ return_variable_relational_6 ≡ 1; */
  return;
}

int fact_aux_4(int x);

void relational_wrapper_4(int x1)
{
  int aux_local_variable_1;
  int return_variable_relational_7;
  int return_variable_relational_8;
  aux_local_variable_1 = x1 + 1;
  {
    int __retres_7;
    if (aux_local_variable_1 <= 1) {
      __retres_7 = 1;
      goto return_label_label_2;
    }
    else {
      int tmp_7;
      tmp_7 = fact_aux_4(aux_local_variable_1 - 1);
      ;
      __retres_7 = aux_local_variable_1 * tmp_7;
      goto return_label_label_2;
    }
    return_label_label_2: return_variable_relational_7 = __retres_7;
  }
  return_variable_relational_8 = fact_aux_4(x1);
  /*@ assert
      Rpp:
        x1 > 1 ⇒
        return_variable_relational_7 ≡
        return_variable_relational_8 * (x1 + 1);
  */
  return;
}

/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior:
      ensures \result ≡ fact_acsl_pure_3(\old(x));
      ensures \result ≡ fact_acsl_pure_4(\old(x));
    
    behavior Relational_behavior_helper:
      ensures ∀ int x; f1_acsl_pure_2(x) ≡ f1_acsl_pure_1(x);
 */
int fact_aux_4(int x);

/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior:
      ensures \result ≡ fact_acsl_pure_3(\old(x));
    
    behavior Relational_behavior_helper:
      ensures ∀ int x; f1_acsl_pure_2(x) ≡ f1_acsl_pure_1(x);
 */
int fact_aux_3(int x);

/*@ requires y > 0;
    assigns \result;
    assigns \result \from y; */
int f2_aux_2(int y);

/*@ requires x > 0;
    assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior:
      ensures \result ≡ f1_acsl_pure_1(\old(x));
 */
int f1_aux_2(int x);


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
