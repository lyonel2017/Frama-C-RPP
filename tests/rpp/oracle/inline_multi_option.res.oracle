[kernel] Parsing tests/rpp/inline_multi_option.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Relational_axiome_1 {
  logic int f1_acsl_pure_1(int x) ;
  
  lemma Relational_lemma_1{L}: ∀ int x1; f1_acsl_pure_1(x1) > 0;
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic int g_acsl_pure_2(int x) ;
  
  logic int f1_acsl_pure_2(int x) ;
  
  logic int f2_acsl_pure_2(int y) ;
  
  lemma Relational_lemma_2{L}:
    ∀ int x1; f1_acsl_pure_2(x1) < f2_acsl_pure_2(x1) < g_acsl_pure_2(x1);
  
  }
 */
/*@ requires x > 0;
    assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_1:
      ensures \result ≡ f1_acsl_pure_1(\old(x));
    
    behavior Relational_behavior_2:
      ensures \result ≡ f1_acsl_pure_2(\old(x));
 */
int f1(int x)
{
  int __retres;
  __retres = x + 1;
  return __retres;
}

/*@ requires y > 0;
    assigns \result;
    assigns \result \from y;
    
    behavior Relational_behavior_2:
      ensures \result ≡ f2_acsl_pure_2(\old(y));
 */
int f2(int y)
{
  int __retres;
  __retres = 2 + y;
  return __retres;
}

/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_2:
      ensures \result ≡ g_acsl_pure_2(\old(x));
 */
int g(int x)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  tmp = f1(x);
  tmp_0 = f2(x);
  tmp_1 = f1(x);
  __retres = (tmp + tmp_0) + tmp_1;
  return __retres;
}

/*@ assigns \result;
    assigns \result \from x; */
int k1(int x)
{
  int temp = 0;
  not_good: ;
  if (! (x > 0)) {
    temp ++;
    goto not_good;
  }
  good: ;
  return temp;
}

/*@
axiomatic Relational_axiome_3 {
  logic int l_acsl_pure_3;
  
  lemma Relational_lemma_3{L}: l_acsl_pure_3 ≡ l_acsl_pure_3;
  
  }

*/
/*@ assigns \result;
    assigns \result \from \nothing;
    
    behavior Relational_behavior_3:
      ensures \result ≡ l_acsl_pure_3;
 */
int l(void)
{
  int __retres;
  int tmp;
  int tmp_0;
  tmp = k1(10);
  tmp_0 = k1(10);
  __retres = tmp + tmp_0;
  return __retres;
}

/*@ requires x1 > 0; */
void relational_wrapper_1(int x1)
{
  int return_variable_relational_1;
  {
    int __retres_1;
    /*@ assert Rpp: x1 > 0; */
    __retres_1 = x1 + 1;
    return_variable_relational_1 = __retres_1;
  }
  /*@ check Rpp: return_variable_relational_1 > 0; */
  return;
}

/*@ requires x1 > 0;
    requires x1 > 0;
    requires x1 > 0; */
void relational_wrapper_2(int x1)
{
  int return_variable_relational_2;
  int return_variable_relational_3;
  int return_variable_relational_4;
  int return_variable_relational_5;
  {
    int __retres_2;
    /*@ assert Rpp: x1 > 0; */
    __retres_2 = x1 + 1;
    return_variable_relational_2 = __retres_2;
  }
  {
    int __retres_3;
    /*@ assert Rpp: x1 > 0; */
    __retres_3 = 2 + x1;
    return_variable_relational_3 = __retres_3;
  }
  {
    int __retres_4;
    /*@ assert Rpp: x1 > 0; */
    __retres_4 = 2 + x1;
    return_variable_relational_4 = __retres_4;
  }
  {
    int __retres_5;
    int tmp_5;
    int tmp_0_5;
    int tmp_1_5;
    {
      int aux_local_variable_1;
      aux_local_variable_1 = x1;
      /*@ assert Rpp: aux_local_variable_1 > 0; */
      {
        int __retres_1;
        __retres_1 = aux_local_variable_1 + 1;
        tmp_5 = __retres_1;
      }
    }
    {
      int aux_local_variable_2;
      aux_local_variable_2 = x1;
      /*@ assert Rpp: aux_local_variable_2 > 0; */
      {
        int __retres_2_16;
        __retres_2_16 = 2 + aux_local_variable_2;
        tmp_0_5 = __retres_2_16;
      }
    }
    {
      int aux_local_variable_3;
      aux_local_variable_3 = x1;
      /*@ assert Rpp: aux_local_variable_3 > 0; */
      {
        int __retres_3_19;
        __retres_3_19 = aux_local_variable_3 + 1;
        tmp_1_5 = __retres_3_19;
      }
    }
    __retres_5 = (tmp_5 + tmp_0_5) + tmp_1_5;
    return_variable_relational_5 = __retres_5;
  }
  /*@ check
      Rpp:
        return_variable_relational_2 < return_variable_relational_3 ∧
        return_variable_relational_4 < return_variable_relational_5;
  */
  return;
}

void relational_wrapper_3(void)
{
  int return_variable_relational_6;
  int return_variable_relational_7;
  {
    int __retres_6;
    int tmp_6;
    int tmp_0_6;
    {
      int aux_local_variable_4;
      aux_local_variable_4 = 10;
      {
        int temp_4 = 0;
        not_good_label_1: ;
        if (! (aux_local_variable_4 > 0)) {
          temp_4 ++;
          goto not_good_label_1;
        }
        good_label_2: ;
        tmp_6 = temp_4;
      }
    }
    {
      int aux_local_variable_5;
      aux_local_variable_5 = 10;
      {
        int temp_5 = 0;
        not_good_label_3: ;
        if (! (aux_local_variable_5 > 0)) {
          temp_5 ++;
          goto not_good_label_3;
        }
        good_label_4: ;
        tmp_0_6 = temp_5;
      }
    }
    __retres_6 = tmp_6 + tmp_0_6;
    return_variable_relational_6 = __retres_6;
  }
  {
    int __retres_7;
    int tmp_7;
    int tmp_0_7;
    {
      int aux_local_variable_6;
      aux_local_variable_6 = 10;
      {
        int temp_6 = 0;
        not_good_label_5: ;
        if (! (aux_local_variable_6 > 0)) {
          temp_6 ++;
          goto not_good_label_5;
        }
        good_label_6: ;
        tmp_7 = temp_6;
      }
    }
    {
      int aux_local_variable_7;
      aux_local_variable_7 = 10;
      {
        int temp_7 = 0;
        not_good_label_7: ;
        if (! (aux_local_variable_7 > 0)) {
          temp_7 ++;
          goto not_good_label_7;
        }
        good_label_8: ;
        tmp_0_7 = temp_7;
      }
    }
    __retres_7 = tmp_7 + tmp_0_7;
    return_variable_relational_7 = __retres_7;
  }
  /*@ check
      Rpp: return_variable_relational_6 ≡ return_variable_relational_7;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
