[kernel] Parsing tests/rpp/Chiffre_de_Cesar_prototype.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
struct tableau {
   int s[100] ;
};
/*@
predicate is_eq(struct tableau q, struct tableau p, int l) =
  ∀ ℤ i; 0 ≤ i < l < 100 ⇒ q.s[i] ≡ p.s[i];
 */
/*@
predicate is_good(struct tableau q, int l) =
  ∀ ℤ k; 0 ≤ k < l < 100 ⇒ 0 ≤ q.s[k] ≤ 126;
 */
/*@
axiomatic Relational_axiome_1 {
  logic struct tableau Cryptage_acsl_pure_1
  (struct tableau Message, int length, int PubKey) ;
  
  lemma Relational_lemma_1{L}:
    ∀ struct tableau message, int key, int length;
      is_good(Cryptage_acsl_pure_1(message, length, key), length);
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic struct tableau Decryptage_acsl_pure_2
  (struct tableau Message, int length, int PubKey) ;
  
  logic struct tableau Cryptage_acsl_pure_2
  (struct tableau Message, int length, int PubKey) ;
  
  lemma Relational_lemma_2{L}:
    ∀ struct tableau message, struct tableau message_beta1,
        struct tableau message_beta2, int key, int length;
      is_eq(message_beta2, message_beta1, length) ⇒
      message_beta1 ≡ Cryptage_acsl_pure_2(message, length, key) ⇒
      is_eq(Decryptage_acsl_pure_2(message_beta2, length, key), message,
           length);
  
  }
 */
/*@ requires 1 ≤ length ≤ 100;
    requires 0 < PubKey < 127;
    requires is_good(Message, length);
    assigns \result;
    assigns \result \from Message, length, PubKey;
    
    behavior Relational_behavior_1:
      ensures
        \result ≡
        Cryptage_acsl_pure_1(\old(Message), \old(length), \old(PubKey));
    
    behavior Relational_behavior_2:
      ensures
        \result ≡
        Cryptage_acsl_pure_2(\old(Message), \old(length), \old(PubKey));
 */
struct tableau Cryptage(struct tableau Message, int length, int PubKey);

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < PubKey < 127;
    requires is_good(Message, length);
    assigns \result;
    assigns \result \from Message, length, PubKey;
    
    behavior Relational_behavior_2:
      ensures
        \result ≡
        Decryptage_acsl_pure_2(\old(Message), \old(length), \old(PubKey));
 */
struct tableau Decryptage(struct tableau Message, int length, int PubKey);

/*@ ensures is_eq(\result, \old(message), \old(len));
    assigns \nothing; */
struct tableau do_something_with_message(struct tableau message, int len);

/*@ requires 1 ≤ len ≤ 100;
    requires is_good(message, len);
    ensures is_eq(\result, \old(message), \old(len));
 */
struct tableau f(struct tableau message, int len)
{
  struct tableau ret;
  int key = 120;
  ret = Cryptage(message,len,key);
  ret = do_something_with_message(ret,len);
  ret = Decryptage(ret,len,key);
  return ret;
}

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < PubKey < 127;
    requires is_good(Message, length);
    assigns \result;
    assigns \result \from Message, length, PubKey;
 */
struct tableau Decryptage_aux_2(struct tableau Message, int length,
                                int PubKey);

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < PubKey < 127;
    requires is_good(Message, length);
    assigns \result;
    assigns \result \from Message, length, PubKey;
    
    behavior Relational_behavior:
      ensures
        \result ≡
        Cryptage_acsl_pure_1(\old(Message), \old(length), \old(PubKey));
 */
struct tableau Cryptage_aux_2(struct tableau Message, int length, int PubKey);

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < PubKey < 127;
    requires is_good(Message, length);
    assigns \result;
    assigns \result \from Message, length, PubKey;
 */
struct tableau Cryptage_aux_1(struct tableau Message, int length, int PubKey);

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < key < 127;
    requires is_good(message, length);
 */
void relational_wrapper_1(struct tableau message, int key, int length)
{
  struct tableau return_variable_relational_1;
  /*@ assert Rpp: 1 ≤ length ≤ 100; */
  /*@ assert Rpp: 0 < key < 127; */
  /*@ assert Rpp: is_good(message, length); */
  return_variable_relational_1 = Cryptage_aux_1(message,length,key);
  /*@ check Rpp: is_good(return_variable_relational_1, length); */
  return;
}

/*@ requires 1 ≤ length ≤ 100;
    requires 0 < key < 127;
    requires is_good(message_beta2, length);
    requires 1 ≤ length ≤ 100;
    requires 0 < key < 127;
    requires is_good(message, length);
 */
void relational_wrapper_2(struct tableau message,
                          struct tableau message_beta1,
                          struct tableau message_beta2, int key, int length)
{
  struct tableau return_variable_relational_2;
  struct tableau return_variable_relational_3;
  /*@ assert Rpp: 1 ≤ length ≤ 100; */
  /*@ assert Rpp: 0 < key < 127; */
  /*@ assert Rpp: is_good(message, length); */
  return_variable_relational_2 = Cryptage_aux_2(message,length,key);
  /*@ assert Rpp: 1 ≤ length ≤ 100; */
  /*@ assert Rpp: 0 < key < 127; */
  /*@ assert Rpp: is_good(message_beta2, length); */
  return_variable_relational_3 = Decryptage_aux_2(message_beta2,length,key);
  /*@ check
      Rpp:
        is_eq(message_beta2, message_beta1, length) ⇒
        message_beta1 ≡ return_variable_relational_2 ⇒
        is_eq(return_variable_relational_3, message, length);
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
