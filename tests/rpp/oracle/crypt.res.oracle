[kernel] Parsing tests/rpp/crypt.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Relational_axiome_2 {
  logic int Cryptage_acsl_pure_2(int t, int key) ;
  
  lemma Relational_lemma_2{L}:
    ∀ int t, int key; Cryptage_acsl_pure_2(t, key) > 0;
  
  }
 */
/*@
axiomatic Relational_axiome_1 {
  logic int Cryptage_acsl_pure_1(int t, int key) ;
  
  logic int DeCryptage_acsl_pure_1(int t, int key) ;
  
  lemma Relational_lemma_1{L}:
    ∀ int t, int key;
      DeCryptage_acsl_pure_1(Cryptage_acsl_pure_1(t, key), key) ≡ t;
  
  }
 */
/*@ requires key ≥ 0 ∧ t > 0;
    assigns \result;
    assigns \result \from t, key;
    
    behavior Relational_behavior_1:
      ensures \result ≡ Cryptage_acsl_pure_1(\old(t), \old(key));
    
    behavior Relational_behavior_2:
      ensures \result ≡ Cryptage_acsl_pure_2(\old(t), \old(key));
 */
int Cryptage(int t, int key)
{
  int __retres;
  __retres = t + key;
  return __retres;
}

/*@ requires key ≥ 0 ∧ t > 0;
    assigns \result;
    assigns \result \from t, key;
    
    behavior Relational_behavior_1:
      ensures \result ≡ DeCryptage_acsl_pure_1(\old(t), \old(key));
 */
int DeCryptage(int t, int key)
{
  int __retres;
  __retres = t - key;
  return __retres;
}

/*@ requires x > 0;
    ensures \result ≡ \old(x); */
int main(int x)
{
  int inter;
  int k = 5;
  inter = Cryptage(x,k);
  inter = DeCryptage(inter,k);
  return inter;
}

/*@ requires key ≥ 0;
    requires key ≥ 0 ∧ t > 0; */
void relational_wrapper_1(int t, int key)
{
  int local_variable_relational_1;
  int return_variable_relational_1;
  {
    int __retres_1;
    /*@ assert Rpp: key ≥ 0 ∧ t > 0; */
    __retres_1 = t + key;
    local_variable_relational_1 = __retres_1;
  }
  {
    int __retres_2;
    /*@ assert Rpp: key ≥ 0 ∧ local_variable_relational_1 > 0; */
    __retres_2 = local_variable_relational_1 - key;
    return_variable_relational_1 = __retres_2;
  }
  /*@ check Rpp: return_variable_relational_1 ≡ t; */
  return;
}

/*@ requires key ≥ 0 ∧ t > 0; */
void relational_wrapper_2(int t, int key)
{
  int return_variable_relational_2;
  {
    int __retres_3;
    /*@ assert Rpp: key ≥ 0 ∧ t > 0; */
    __retres_3 = t + key;
    return_variable_relational_2 = __retres_3;
  }
  /*@ check Rpp: return_variable_relational_2 > 0; */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
