[kernel] Parsing tests/rpp/axiom_separated.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
int *y;
/*@
axiomatic Relational_axiome_1 {
  predicate k_acsl_1{pre}
    (int *t, int n, int *y, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre), \at(*y,pre);
  
  lemma Relational_lemma_1{pre_id1}:
    ∀ int x, int *tb, int *y_id1, int return_variable_relational_1;
      \separated(y_id1, tb + (0 .. x)) ⇒
      k_acsl_1(tb, x, y_id1, return_variable_relational_1) ⇒
      return_variable_relational_1 ≡
      \at(*(tb + 1),pre_id1) + \at(*(tb + (x - 1)),pre_id1);
  
  }
 */
/*@ requires \separated(t + (0 .. n), y);
    requires n > 0;
    assigns \result;
    assigns \result \from n, *(t + (0 .. n)), *y;
    
    behavior Relational_behavior_1:
      ensures k_acsl_1{Pre}(\old(t), \old(n), y, \result);
 */
int k(int *t, int n)
{
  int __retres;
  __retres = (*(t + 1) + *(t + (n - 1))) + *y;
  return __retres;
}

int *y_id1_1;

/*@ requires \separated(y_id1_1, tb + (0 .. x));
    requires \separated(tb + (0 .. x), y_id1_1);
    requires x > 0;
 */
void relational_wrapper_1(int x, int *tb)
{
  int return_variable_relational_1;
  {
    int __retres_1;
    /*@ assert Rpp: \separated(tb + (0 .. x), y_id1_1); */
    /*@ assert Rpp: x > 0; */
    __retres_1 = (*(tb + 1) + *(tb + (x - 1))) + *y_id1_1;
    return_variable_relational_1 = __retres_1;
  }
  /*@ check
      Rpp:
        return_variable_relational_1 ≡
        \at(*(tb + 1),Pre) + \at(*(tb + (x - 1)),Pre);
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
