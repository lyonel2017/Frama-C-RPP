[kernel] Parsing tests/rpp/and_more_paramter.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
int y;
/*@
axiomatic Relational_axiome_1 {
  logic int f_acsl_pure_1(int x) ;
  
  predicate g_acsl_1
    (int x, int y_pre, int y_post, int return_variable_relational) ;
  
  lemma Relational_lemma_1{L}:
    ∀ int x, int k, int y_id2_pre, int y_id2_post,
        int return_variable_relational_2, int y_id1_pre, int y_id1_post,
        int return_variable_relational_1;
      g_acsl_1(f_acsl_pure_1(k), y_id2_pre, y_id2_post,
              return_variable_relational_2) ⇒
      g_acsl_1(x, y_id1_pre, y_id1_post, return_variable_relational_1) ⇒
      y_id1_pre ≡ y_id2_pre ∧ x > 0 ∧ y_id1_pre > 0 ∧
      y_id2_pre > 0 ∧ k ≡ return_variable_relational_1 ⇒
      y_id1_post < y_id2_post;
  
  }
 */
/*@ assigns \result;
    assigns \result \from x;
    
    behavior Relational_behavior_1:
      ensures \result ≡ f_acsl_pure_1(\old(x));
 */
int f(int x)
{
  int __retres;
  __retres = x + 1;
  return __retres;
}

/*@ assigns y;
    assigns y \from y, x;
    
    behavior Relational_behavior_1:
      ensures g_acsl_1(\old(x), \at(y,Pre), \at(y,Post), \result);
 */
int g(int x)
{
  y += x;
  return y;
}

int y_id1_1;

int y_id2_1;

void relational_wrapper_1(int x, int k)
{
  int return_variable_relational_1;
  int local_variable_relational_1;
  int return_variable_relational_2;
  y_id1_1 += x;
  return_variable_relational_1 = y_id1_1;
  {
    int __retres_2;
    __retres_2 = k + 1;
    local_variable_relational_1 = __retres_2;
  }
  y_id2_1 += local_variable_relational_1;
  return_variable_relational_2 = y_id2_1;
  /*@ assert
      Rpp:
        \at(y_id1_1,Pre) ≡ \at(y_id2_1,Pre) ∧ x > 0 ∧
        \at(y_id1_1,Pre) > 0 ∧ \at(y_id2_1,Pre) > 0 ∧
        k ≡ return_variable_relational_1 ⇒
        \at(y_id1_1,Here) < \at(y_id2_1,Here);
  */
  return;
}

int l;
/*@
axiomatic Relational_axiome_2 {
  predicate j_acsl_2(int x, int l_post) ;
  
  predicate p_acsl_2(int l_pre, int l_post) ;
  
  lemma Relational_lemma_2{L}:
    ∀ int x, int l_id5_pre, int l_id5_post, int l_id4_post, int l_id3_pre,
        int l_id3_post;
      p_acsl_2(l_id5_pre, l_id5_post) ⇒
      j_acsl_2(x, l_id4_post) ⇒
      p_acsl_2(l_id3_pre, l_id3_post) ⇒
      x ≡ l_id3_post ∧ l_id3_pre ≡ l_id5_pre ⇒
      l_id4_post ≡ l_id5_post;
  
  }

*/
/*@ assigns l;
    assigns l \from x;
    
    behavior Relational_behavior_2:
      ensures j_acsl_2(\old(x), \at(l,Post));
 */
void j(int x)
{
  l = x;
  return;
}

/*@ assigns l;
    assigns l \from l;
    
    behavior Relational_behavior_2:
      ensures p_acsl_2(\at(l,Pre), \at(l,Post));
 */
void p(void)
{
  l ++;
  return;
}

int l_id3_2;

int l_id4_2;

int l_id5_2;

void relational_wrapper_2(int x)
{
  l_id3_2 ++;
  ;
  l_id4_2 = x;
  ;
  l_id5_2 ++;
  ;
  /*@ assert
      Rpp:
        x ≡ \at(l_id3_2,Here) ∧ \at(l_id3_2,Pre) ≡ \at(l_id5_2,Pre) ⇒
        \at(l_id4_2,Here) ≡ \at(l_id5_2,Here);
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
