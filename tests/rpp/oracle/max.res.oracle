[kernel] Parsing tests/rpp/max.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
/*@
axiomatic Relational_axiome_1 {
  predicate f_acsl_1{pre}(int *t, int n, int return_variable_relational) 
    reads \at(*(t + (0 .. n)),pre);
  
  lemma Relational_lemma_1{pre_id4, pre_id3, pre_id2, pre_id1}:
    ∀ int *t1, int *t2, int *tn, int *t, int return_variable_relational_4,
        int return_variable_relational_3, int return_variable_relational_2,
        int return_variable_relational_1;
      \separated(t2 + (0 .. (int)2), t1 + (0 .. (int)2)) ⇒
      \separated(tn + (0 .. (int)2), t1 + (0 .. (int)2)) ⇒
      \separated(tn + (0 .. (int)2), t2 + (0 .. (int)2)) ⇒
      \separated(t + (0 .. (int)4), t1 + (0 .. (int)2)) ⇒
      \separated(t + (0 .. (int)4), t2 + (0 .. (int)2)) ⇒
      \separated(t + (0 .. (int)4), tn + (0 .. (int)2)) ⇒
      f_acsl_1{pre_id4}(t, (int)4, return_variable_relational_4) ⇒
      f_acsl_1{pre_id3}(tn, (int)2, return_variable_relational_3) ⇒
      f_acsl_1{pre_id2}(t2, (int)2, return_variable_relational_2) ⇒
      f_acsl_1{pre_id1}(t1, (int)2, return_variable_relational_1) ⇒
      \at(*(tn + 0),pre_id3) ≡ return_variable_relational_1 ∧
      \at(*(tn + 1),pre_id3) ≡ return_variable_relational_2 ∧
      \at(*(t + 0),pre_id4) ≡ \at(*(t1 + 0),pre_id1) ∧
      \at(*(t + 1),pre_id4) ≡ \at(*(t1 + 1),pre_id1) ∧
      \at(*(t + 2),pre_id4) ≡ \at(*(t2 + 0),pre_id2) ∧
      \at(*(t + 3),pre_id4) ≡ \at(*(t2 + 1),pre_id2) ⇒
      return_variable_relational_3 ≡ return_variable_relational_4;
  
  }
 */
/*@ requires \valid(t + (0 .. n));
    requires n ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < n ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. n));
    ensures ∀ ℤ k; 0 ≤ k < \old(n) ⇒ \result ≥ *(\old(t) + k);
    ensures ∃ ℤ k; 0 ≤ k < \old(n) ∧ \result ≡ *(\old(t) + k);
    assigns \result;
    assigns \result \from *(t + (0 .. n));
    
    behavior Relational_behavior_1:
      ensures f_acsl_1{Pre}(\old(t), \old(n), \result);
 */
int f(int *t, int n)
{
  int max = *(t + 0);
  int i = 0;
  /*@ loop invariant 0 ≤ i ≤ n;
      loop invariant ∀ ℤ k; 0 ≤ k < i ⇒ max ≥ *(t + k);
      loop invariant ∃ ℤ k; 0 ≤ k < n ∧ max ≡ *(t + k);
      loop assigns i, max;
      loop variant n - i;
  */
  while (i < n) {
    if (*(t + i) > max) max = *(t + i);
    i ++;
  }
  return max;
}

/*@ requires \valid(t + (0 .. n));
    requires n ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < n ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. n));
    ensures ∀ ℤ k; 0 ≤ k < \old(n) ⇒ \result ≥ *(\old(t) + k);
    ensures ∃ ℤ k; 0 ≤ k < \old(n) ∧ \result ≡ *(\old(t) + k);
    assigns \result;
    assigns \result \from *(t + (0 .. n));
 */
int f_id4(int *t, int n);

/*@ requires \valid(t + (0 .. n));
    requires n ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < n ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. n));
    ensures ∀ ℤ k; 0 ≤ k < \old(n) ⇒ \result ≥ *(\old(t) + k);
    ensures ∃ ℤ k; 0 ≤ k < \old(n) ∧ \result ≡ *(\old(t) + k);
    assigns \result;
    assigns \result \from *(t + (0 .. n));
 */
int f_id3(int *t, int n);

/*@ requires \valid(t + (0 .. n));
    requires n ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < n ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. n));
    ensures ∀ ℤ k; 0 ≤ k < \old(n) ⇒ \result ≥ *(\old(t) + k);
    ensures ∃ ℤ k; 0 ≤ k < \old(n) ∧ \result ≡ *(\old(t) + k);
    assigns \result;
    assigns \result \from *(t + (0 .. n));
 */
int f_id2(int *t, int n);

/*@ requires \valid(t + (0 .. n));
    requires n ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < n ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. n));
    ensures ∀ ℤ k; 0 ≤ k < \old(n) ⇒ \result ≥ *(\old(t) + k);
    ensures ∃ ℤ k; 0 ≤ k < \old(n) ∧ \result ≡ *(\old(t) + k);
    assigns \result;
    assigns \result \from *(t + (0 .. n));
 */
int f_id1(int *t, int n);

/*@ requires
      \separated(
        t2 + (0 .. aux_local_variable_2), t1 + (0 .. aux_local_variable_1)
        );
    requires
      \separated(
        tn + (0 .. aux_local_variable_3), t1 + (0 .. aux_local_variable_1)
        );
    requires
      \separated(
        tn + (0 .. aux_local_variable_3), t2 + (0 .. aux_local_variable_2)
        );
    requires
      \separated(
        t + (0 .. aux_local_variable_4), t1 + (0 .. aux_local_variable_1)
        );
    requires
      \separated(
        t + (0 .. aux_local_variable_4), t2 + (0 .. aux_local_variable_2)
        );
    requires
      \separated(
        t + (0 .. aux_local_variable_4), tn + (0 .. aux_local_variable_3)
        );
    requires \valid(t + (0 .. 4));
    requires 4 ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < 4 ⇒ 0 ≤ *(t + k);
    requires \separated(t + (0 .. 4));
    requires \valid(tn + (0 .. 2));
    requires 2 ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < 2 ⇒ 0 ≤ *(tn + k);
    requires \separated(tn + (0 .. 2));
    requires \valid(t2 + (0 .. 2));
    requires 2 ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < 2 ⇒ 0 ≤ *(t2 + k);
    requires \separated(t2 + (0 .. 2));
    requires \valid(t1 + (0 .. 2));
    requires 2 ≥ 1;
    requires ∀ ℤ k; 0 ≤ k < 2 ⇒ 0 ≤ *(t1 + k);
    requires \separated(t1 + (0 .. 2));
 */
void relational_wrapper_1(int *t1, int *t2, int *tn, int *t)
{
  int aux_local_variable_1;
  int return_variable_relational_1;
  int aux_local_variable_2;
  int return_variable_relational_2;
  int aux_local_variable_3;
  int return_variable_relational_3;
  int aux_local_variable_4;
  int return_variable_relational_4;
  aux_local_variable_1 = 2;
  /*@ assert Rpp: \valid(t1 + (0 .. aux_local_variable_1)); */
  /*@ assert Rpp: aux_local_variable_1 ≥ 1; */
  /*@ assert
      Rpp: ∀ ℤ k; 0 ≤ k < aux_local_variable_1 ⇒ 0 ≤ *(t1 + k);
  */
  /*@ assert Rpp: \separated(t1 + (0 .. aux_local_variable_1)); */
  return_variable_relational_1 = f_id1(t1,aux_local_variable_1);
  aux_local_variable_2 = 2;
  /*@ assert Rpp: \valid(t2 + (0 .. aux_local_variable_2)); */
  /*@ assert Rpp: aux_local_variable_2 ≥ 1; */
  /*@ assert
      Rpp: ∀ ℤ k; 0 ≤ k < aux_local_variable_2 ⇒ 0 ≤ *(t2 + k);
  */
  /*@ assert Rpp: \separated(t2 + (0 .. aux_local_variable_2)); */
  return_variable_relational_2 = f_id2(t2,aux_local_variable_2);
  aux_local_variable_3 = 2;
  /*@ assert Rpp: \valid(tn + (0 .. aux_local_variable_3)); */
  /*@ assert Rpp: aux_local_variable_3 ≥ 1; */
  /*@ assert
      Rpp: ∀ ℤ k; 0 ≤ k < aux_local_variable_3 ⇒ 0 ≤ *(tn + k);
  */
  /*@ assert Rpp: \separated(tn + (0 .. aux_local_variable_3)); */
  return_variable_relational_3 = f_id3(tn,aux_local_variable_3);
  aux_local_variable_4 = 4;
  /*@ assert Rpp: \valid(t + (0 .. aux_local_variable_4)); */
  /*@ assert Rpp: aux_local_variable_4 ≥ 1; */
  /*@ assert
      Rpp: ∀ ℤ k; 0 ≤ k < aux_local_variable_4 ⇒ 0 ≤ *(t + k);
  */
  /*@ assert Rpp: \separated(t + (0 .. aux_local_variable_4)); */
  return_variable_relational_4 = f_id4(t,aux_local_variable_4);
  /*@ check
      Rpp:
        \at(*(tn + 0),Pre) ≡ return_variable_relational_1 ∧
        \at(*(tn + 1),Pre) ≡ return_variable_relational_2 ∧
        \at(*(t + 0),Pre) ≡ \at(*(t1 + 0),Pre) ∧
        \at(*(t + 1),Pre) ≡ \at(*(t1 + 1),Pre) ∧
        \at(*(t + 2),Pre) ≡ \at(*(t2 + 0),Pre) ∧
        \at(*(t + 3),Pre) ≡ \at(*(t2 + 1),Pre) ⇒
        return_variable_relational_3 ≡ return_variable_relational_4;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
