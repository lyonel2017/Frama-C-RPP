[kernel] Parsing tests/rpp/includes.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
#include "stdint.h"
uint8_t y;
/*@
axiomatic Relational_axiome_1 {
  logic uint32_t f_acsl_pure_1(uint32_t x_0) ;
  
  lemma Relational_lemma_1{L}:
    ∀ unsigned int x1, unsigned int x2;
      x1 < x2 ⇒ f_acsl_pure_1(x1) < f_acsl_pure_1(x2);
  
  }

*/
/*@ requires x_0 > 0;
    assigns \result;
    assigns \result \from x_0;
    
    behavior Relational_behavior_1:
      ensures \result ≡ f_acsl_pure_1(\old(x_0));
 */
uint32_t f(uint32_t x_0)
{
  uint32_t __retres;
  __retres = x_0 + (uint32_t)1;
  return __retres;
}

/*@
axiomatic Relational_axiome_2 {
  predicate g_acsl_2(uint8_t y_pre, uint32_t return_variable_relational) ;
  
  lemma Relational_lemma_2{L}:
    ∀ uint8_t y_id1_pre, uint32_t return_variable_relational_1;
      g_acsl_2(y_id1_pre, return_variable_relational_1) ⇒ 0 ≡ 0;
  
  }

*/
/*@ assigns \result;
    assigns \result \from y;
    
    behavior Relational_behavior_2:
      ensures g_acsl_2(\at(y,Pre), \result);
 */
uint32_t g(void)
{
  uint32_t __retres;
  __retres = (unsigned int)y;
  return __retres;
}

/*@
axiomatic Relational_axiome_3 {
  predicate k_acsl_3(uint8_t y_pre, uint32_t return_variable_relational) ;
  
  lemma Relational_lemma_3{L}:
    ∀ uint8_t y_id1_pre, uint32_t return_variable_relational_2;
      k_acsl_3(y_id1_pre, return_variable_relational_2) ⇒
      return_variable_relational_2 ≡ 0;
  
  }

*/
/*@ assigns \result;
    assigns \result \from y;
    
    behavior Relational_behavior_3:
      ensures k_acsl_3(\at(y,Pre), \result);
 */
uint32_t k(void)
{
  uint32_t __retres;
  __retres = (unsigned int)y;
  return __retres;
}

uint8_t *x;
/*@
axiomatic Relational_axiome_4 {
  predicate h_acsl_4{pre}(uint8_t *x, uint8_t return_variable_relational) 
    reads \at(*x,pre);
  
  lemma Relational_lemma_4{pre_id1}:
    ∀ uint8_t *x_id1, uint8_t return_variable_relational_3;
      h_acsl_4(x_id1, return_variable_relational_3) ⇒
      return_variable_relational_3 ≡ 0;
  
  }

*/
/*@ assigns \result;
    assigns \result \from *x;
    
    behavior Relational_behavior_4:
      ensures h_acsl_4{Pre}(x, \result);
 */
uint8_t h(void)
{
  uint8_t __retres;
  __retres = *x;
  return __retres;
}

/*@ requires x2 > 0;
    requires x1 > 0; */
void relational_wrapper_1(unsigned int x1, unsigned int x2)
{
  uint32_t return_variable_relational_1;
  uint32_t return_variable_relational_2;
  {
    uint32_t __retres_1;
    /*@ assert Rpp: x1 > 0; */
    __retres_1 = x1 + (uint32_t)1;
    return_variable_relational_1 = __retres_1;
  }
  {
    uint32_t __retres_2;
    /*@ assert Rpp: x2 > 0; */
    __retres_2 = x2 + (uint32_t)1;
    return_variable_relational_2 = __retres_2;
  }
  /*@ check
      Rpp:
        x1 < x2 ⇒
        return_variable_relational_1 < return_variable_relational_2;
  */
  return;
}

uint8_t y_id1_2;

void relational_wrapper_2(void)
{
  uint32_t return_variable_relational_3;
  {
    uint32_t __retres_3;
    __retres_3 = (unsigned int)y_id1_2;
    return_variable_relational_3 = __retres_3;
  }
  /*@ check Rpp: 0 ≡ 0; */
  return;
}

uint8_t y_id1_3;

void relational_wrapper_3(void)
{
  uint32_t return_variable_relational_4;
  {
    uint32_t __retres_4;
    __retres_4 = (unsigned int)y_id1_3;
    return_variable_relational_4 = __retres_4;
  }
  /*@ check Rpp: return_variable_relational_4 ≡ 0; */
  return;
}

uint8_t *x_id1_4;

void relational_wrapper_4(void)
{
  uint8_t return_variable_relational_5;
  {
    uint8_t __retres_5;
    __retres_5 = *x_id1_4;
    return_variable_relational_5 = __retres_5;
  }
  /*@ check Rpp: return_variable_relational_5 ≡ 0; */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
