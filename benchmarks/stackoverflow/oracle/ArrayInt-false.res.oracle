[kernel] Parsing tests/../benchmarks/stackoverflow/ArrayInt-false.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
struct AInt {
   int t[1000] ;
   int length ;
};
/*@
axiomatic Relational_axiome_3 {
  logic int compare_acsl_pure_3(struct AInt o1, struct AInt o2) ;
  
  lemma Relational_lemma_3{L}:
    ∀ struct AInt x1, struct AInt x2, struct AInt x3;
      compare_acsl_pure_3(x1, x2) ≡ 0 ⇒
      compare_acsl_pure_3(x1, x3) ≡ compare_acsl_pure_3(x2, x3);
  
  }
 */
/*@
axiomatic Relational_axiome_1 {
  logic int compare_acsl_pure_1(struct AInt o1, struct AInt o2) ;
  
  lemma Relational_lemma_1{L}:
    ∀ struct AInt x1, struct AInt x2;
      compare_acsl_pure_1(x1, x2) ≡ -compare_acsl_pure_1(x2, x1);
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic int compare_acsl_pure_2(struct AInt o1, struct AInt o2) ;
  
  lemma Relational_lemma_2{L}:
    ∀ struct AInt x1, struct AInt x2, struct AInt x3;
      compare_acsl_pure_2(x1, x2) > 0 ∧ compare_acsl_pure_2(x2, x3) > 0 ⇒
      compare_acsl_pure_2(x1, x3) > 0;
  
  }
 */
/*@ requires 0 ≤ o1.length < 1000;
    requires 0 ≤ o2.length < 1000;
    assigns \result;
    assigns \result \from o1, o2;
    
    behavior Relational_behavior_1:
      ensures \result ≡ compare_acsl_pure_1(\old(o1), \old(o2));
    
    behavior Relational_behavior_2:
      ensures \result ≡ compare_acsl_pure_2(\old(o1), \old(o2));
    
    behavior Relational_behavior_3:
      ensures \result ≡ compare_acsl_pure_3(\old(o1), \old(o2));
 */
int compare(struct AInt o1, struct AInt o2)
{
  int __retres;
  int index;
  int aentry;
  int bentry;
  index = 0;
  /*@ loop invariant 0 ≤ index ≤ o2.length ∧ index ≤ o1.length;
      loop invariant ∀ ℤ k; 0 ≤ k < index ⇒ o1.t[k] ≡ o2.t[k];
      loop assigns index, aentry, bentry;
  */
  while (1) {
    if (index < o1.length) {
      if (! (index < o2.length)) break;
    }
    else break;
    aentry = o1.t[index];
    bentry = o2.t[index];
    if (aentry < bentry) {
      __retres = -1;
      goto return_label;
    }
    if (aentry > bentry) {
      __retres = 1;
      goto return_label;
    }
    index ++;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires 0 ≤ x2.length < 1000;
    requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x2.length < 1000;
 */
void relational_wrapper_1(struct AInt x1, struct AInt x2)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  {
    int __retres_1;
    int index_1;
    int aentry_1;
    int bentry_1;
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    index_1 = 0;
    /*@ loop invariant 0 ≤ index_1 ≤ x2.length ∧ index_1 ≤ x1.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_1 ⇒ x1.t[k] ≡ x2.t[k];
        loop assigns index_1, aentry_1, bentry_1;
    */
    while (1) {
      if (index_1 < x1.length) {
        if (! (index_1 < x2.length)) break;
      }
      else break;
      aentry_1 = x1.t[index_1];
      bentry_1 = x2.t[index_1];
      if (aentry_1 < bentry_1) {
        __retres_1 = -1;
        goto return_label_label_1;
      }
      if (aentry_1 > bentry_1) {
        __retres_1 = 1;
        goto return_label_label_1;
      }
      index_1 ++;
    }
    __retres_1 = 0;
    return_label_label_1: return_variable_relational_1 = __retres_1;
  }
  {
    int __retres_2;
    int index_2;
    int aentry_2;
    int bentry_2;
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    index_2 = 0;
    /*@ loop invariant 0 ≤ index_2 ≤ x1.length ∧ index_2 ≤ x2.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_2 ⇒ x2.t[k] ≡ x1.t[k];
        loop assigns index_2, aentry_2, bentry_2;
    */
    while (1) {
      if (index_2 < x2.length) {
        if (! (index_2 < x1.length)) break;
      }
      else break;
      aentry_2 = x2.t[index_2];
      bentry_2 = x1.t[index_2];
      if (aentry_2 < bentry_2) {
        __retres_2 = -1;
        goto return_label_label_2;
      }
      if (aentry_2 > bentry_2) {
        __retres_2 = 1;
        goto return_label_label_2;
      }
      index_2 ++;
    }
    __retres_2 = 0;
    return_label_label_2: return_variable_relational_2 = __retres_2;
  }
  /*@ assert
      Rpp: return_variable_relational_1 ≡ -return_variable_relational_2;
  */
  return;
}

/*@ requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x3.length < 1000;
    requires 0 ≤ x2.length < 1000;
    requires 0 ≤ x3.length < 1000;
    requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x2.length < 1000;
 */
void relational_wrapper_2(struct AInt x1, struct AInt x2, struct AInt x3)
{
  int return_variable_relational_3;
  int return_variable_relational_4;
  int return_variable_relational_5;
  {
    int __retres_3;
    int index_3;
    int aentry_3;
    int bentry_3;
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    index_3 = 0;
    /*@ loop invariant 0 ≤ index_3 ≤ x2.length ∧ index_3 ≤ x1.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_3 ⇒ x1.t[k] ≡ x2.t[k];
        loop assigns index_3, aentry_3, bentry_3;
    */
    while (1) {
      if (index_3 < x1.length) {
        if (! (index_3 < x2.length)) break;
      }
      else break;
      aentry_3 = x1.t[index_3];
      bentry_3 = x2.t[index_3];
      if (aentry_3 < bentry_3) {
        __retres_3 = -1;
        goto return_label_label_3;
      }
      if (aentry_3 > bentry_3) {
        __retres_3 = 1;
        goto return_label_label_3;
      }
      index_3 ++;
    }
    __retres_3 = 0;
    return_label_label_3: return_variable_relational_3 = __retres_3;
  }
  {
    int __retres_4;
    int index_4;
    int aentry_4;
    int bentry_4;
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    /*@ assert Rpp: 0 ≤ x3.length < 1000; */
    index_4 = 0;
    /*@ loop invariant 0 ≤ index_4 ≤ x3.length ∧ index_4 ≤ x2.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_4 ⇒ x2.t[k] ≡ x3.t[k];
        loop assigns index_4, aentry_4, bentry_4;
    */
    while (1) {
      if (index_4 < x2.length) {
        if (! (index_4 < x3.length)) break;
      }
      else break;
      aentry_4 = x2.t[index_4];
      bentry_4 = x3.t[index_4];
      if (aentry_4 < bentry_4) {
        __retres_4 = -1;
        goto return_label_label_4;
      }
      if (aentry_4 > bentry_4) {
        __retres_4 = 1;
        goto return_label_label_4;
      }
      index_4 ++;
    }
    __retres_4 = 0;
    return_label_label_4: return_variable_relational_4 = __retres_4;
  }
  {
    int __retres_5;
    int index_5;
    int aentry_5;
    int bentry_5;
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    /*@ assert Rpp: 0 ≤ x3.length < 1000; */
    index_5 = 0;
    /*@ loop invariant 0 ≤ index_5 ≤ x3.length ∧ index_5 ≤ x1.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_5 ⇒ x1.t[k] ≡ x3.t[k];
        loop assigns index_5, aentry_5, bentry_5;
    */
    while (1) {
      if (index_5 < x1.length) {
        if (! (index_5 < x3.length)) break;
      }
      else break;
      aentry_5 = x1.t[index_5];
      bentry_5 = x3.t[index_5];
      if (aentry_5 < bentry_5) {
        __retres_5 = -1;
        goto return_label_label_5;
      }
      if (aentry_5 > bentry_5) {
        __retres_5 = 1;
        goto return_label_label_5;
      }
      index_5 ++;
    }
    __retres_5 = 0;
    return_label_label_5: return_variable_relational_5 = __retres_5;
  }
  /*@ assert
      Rpp:
        return_variable_relational_3 > 0 ∧ return_variable_relational_4 > 0 ⇒
        return_variable_relational_5 > 0;
  */
  return;
}

/*@ requires 0 ≤ x2.length < 1000;
    requires 0 ≤ x3.length < 1000;
    requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x3.length < 1000;
    requires 0 ≤ x1.length < 1000;
    requires 0 ≤ x2.length < 1000;
 */
void relational_wrapper_3(struct AInt x1, struct AInt x2, struct AInt x3)
{
  int return_variable_relational_6;
  int return_variable_relational_7;
  int return_variable_relational_8;
  {
    int __retres_6;
    int index_6;
    int aentry_6;
    int bentry_6;
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    index_6 = 0;
    /*@ loop invariant 0 ≤ index_6 ≤ x2.length ∧ index_6 ≤ x1.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_6 ⇒ x1.t[k] ≡ x2.t[k];
        loop assigns index_6, aentry_6, bentry_6;
    */
    while (1) {
      if (index_6 < x1.length) {
        if (! (index_6 < x2.length)) break;
      }
      else break;
      aentry_6 = x1.t[index_6];
      bentry_6 = x2.t[index_6];
      if (aentry_6 < bentry_6) {
        __retres_6 = -1;
        goto return_label_label_6;
      }
      if (aentry_6 > bentry_6) {
        __retres_6 = 1;
        goto return_label_label_6;
      }
      index_6 ++;
    }
    __retres_6 = 0;
    return_label_label_6: return_variable_relational_6 = __retres_6;
  }
  {
    int __retres_7;
    int index_7;
    int aentry_7;
    int bentry_7;
    /*@ assert Rpp: 0 ≤ x1.length < 1000; */
    /*@ assert Rpp: 0 ≤ x3.length < 1000; */
    index_7 = 0;
    /*@ loop invariant 0 ≤ index_7 ≤ x3.length ∧ index_7 ≤ x1.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_7 ⇒ x1.t[k] ≡ x3.t[k];
        loop assigns index_7, aentry_7, bentry_7;
    */
    while (1) {
      if (index_7 < x1.length) {
        if (! (index_7 < x3.length)) break;
      }
      else break;
      aentry_7 = x1.t[index_7];
      bentry_7 = x3.t[index_7];
      if (aentry_7 < bentry_7) {
        __retres_7 = -1;
        goto return_label_label_7;
      }
      if (aentry_7 > bentry_7) {
        __retres_7 = 1;
        goto return_label_label_7;
      }
      index_7 ++;
    }
    __retres_7 = 0;
    return_label_label_7: return_variable_relational_7 = __retres_7;
  }
  {
    int __retres_8;
    int index_8;
    int aentry_8;
    int bentry_8;
    /*@ assert Rpp: 0 ≤ x2.length < 1000; */
    /*@ assert Rpp: 0 ≤ x3.length < 1000; */
    index_8 = 0;
    /*@ loop invariant 0 ≤ index_8 ≤ x3.length ∧ index_8 ≤ x2.length;
        loop invariant ∀ ℤ k; 0 ≤ k < index_8 ⇒ x2.t[k] ≡ x3.t[k];
        loop assigns index_8, aentry_8, bentry_8;
    */
    while (1) {
      if (index_8 < x2.length) {
        if (! (index_8 < x3.length)) break;
      }
      else break;
      aentry_8 = x2.t[index_8];
      bentry_8 = x3.t[index_8];
      if (aentry_8 < bentry_8) {
        __retres_8 = -1;
        goto return_label_label_8;
      }
      if (aentry_8 > bentry_8) {
        __retres_8 = 1;
        goto return_label_label_8;
      }
      index_8 ++;
    }
    __retres_8 = 0;
    return_label_label_8: return_variable_relational_8 = __retres_8;
  }
  /*@ assert
      Rpp:
        return_variable_relational_6 ≡ 0 ⇒
        return_variable_relational_7 ≡ return_variable_relational_8;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
