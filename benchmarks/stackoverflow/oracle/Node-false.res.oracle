[kernel] Parsing tests/../benchmarks/stackoverflow/Node-false.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
struct Node {
   int ID ;
};
/*@ requires 0 ≤ id < 1000;
    ensures *(\old(t) + \old(id)) ≢ -1 ⇒ \result ≡ 1;
    ensures *(\old(t) + \old(id)) ≡ -1 ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int containsKey(int id, int *t);

/*@ requires 0 ≤ id < 1000;
    ensures \result ≡ *(\old(t) + \old(id));
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int get(int id, int *t);

/*@ ensures \result ≡ \old(o1.ID);
    ensures 0 ≤ \result < 1000;
    assigns \result;
    assigns \result \from o1;
 */
int getID(struct Node o1);

/*@
axiomatic Relational_axiome_3 {
  logic int compare_acsl_pure_3(struct Node o1, struct Node o2, int *Map) ;
  
  lemma Relational_lemma_3{L}:
    ∀ struct Node x1, struct Node x2, struct Node x3, int *Map;
      compare_acsl_pure_3(x1, x2, Map) ≡ 0 ⇒
      compare_acsl_pure_3(x1, x3, Map) ≡ compare_acsl_pure_3(x2, x3, Map);
  
  }
 */
/*@
axiomatic Relational_axiome_1 {
  logic int compare_acsl_pure_1(struct Node o1, struct Node o2, int *Map) ;
  
  lemma Relational_lemma_1{L}:
    ∀ struct Node x1, struct Node x2, int *Map;
      compare_acsl_pure_1(x1, x2, Map) ≡ -compare_acsl_pure_1(x2, x1, Map);
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic int compare_acsl_pure_2(struct Node o1, struct Node o2, int *Map) ;
  
  lemma Relational_lemma_2{L}:
    ∀ struct Node x1, struct Node x2, struct Node x3, int *Map;
      compare_acsl_pure_2(x1, x2, Map) > 0 ∧
      compare_acsl_pure_2(x2, x3, Map) > 0 ⇒
      compare_acsl_pure_2(x1, x3, Map) > 0;
  
  }
 */
/*@ requires \valid(Map + (0 .. 1000));
    assigns \result;
    assigns \result \from o1, o2, *(Map + (0 .. 100));
    
    behavior Relational_behavior_1:
      ensures \result ≡ compare_acsl_pure_1(\old(o1), \old(o2), \old(Map));
    
    behavior Relational_behavior_2:
      ensures \result ≡ compare_acsl_pure_2(\old(o1), \old(o2), \old(Map));
    
    behavior Relational_behavior_3:
      ensures \result ≡ compare_acsl_pure_3(\old(o1), \old(o2), \old(Map));
 */
int compare(struct Node o1, struct Node o2, int *Map)
{
  int __retres;
  int tmp_4;
  int tmp_3;
  ;
  tmp_3 = getID(o1);
  tmp_4 = containsKey(tmp_3,Map);
  if (tmp_4) {
    int tmp_6;
    int tmp_5;
    ;
    tmp_5 = getID(o2);
    tmp_6 = containsKey(tmp_5,Map);
    if (tmp_6) {
      int tmp_0;
      int tmp;
      int tmp_2;
      int tmp_1;
      ;
      tmp = getID(o1);
      tmp_0 = get(tmp,Map);
      int order1 = tmp_0;
      ;
      tmp_1 = getID(o2);
      tmp_2 = get(tmp_1,Map);
      int order2 = tmp_2;
      if (order1 < order2) {
        __retres = -1;
        goto return_label;
      }
      else 
        if (order1 > order2) {
          __retres = 1;
          goto return_label;
        }
        else {
          __retres = 0;
          goto return_label;
        }
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int getID_aux_1(struct Node o1);

int containsKey_aux_1(int id, int *t);

int get_aux_1(int id, int *t);

/*@ requires \valid(Map + (0 .. 1000));
    requires \valid(Map + (0 .. 1000)); */
void relational_wrapper_1(struct Node x1, struct Node x2, int *Map)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  {
    int __retres_1;
    int tmp_4_1;
    int tmp_3_1;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_1 = getID_aux_1(x1);
    }
    tmp_4_1 = containsKey_aux_1(tmp_3_1,Map);
    if (tmp_4_1) {
      int tmp_6_1;
      int tmp_5_1;
      ;
      tmp_5_1 = getID_aux_1(x2);
      tmp_6_1 = containsKey_aux_1(tmp_5_1,Map);
      if (tmp_6_1) {
        int tmp_0_1;
        int tmp_1;
        int tmp_2_1;
        int tmp_1_1;
        ;
        tmp_1 = getID_aux_1(x1);
        tmp_0_1 = get_aux_1(tmp_1,Map);
        int order1_1 = tmp_0_1;
        ;
        tmp_1_1 = getID_aux_1(x2);
        tmp_2_1 = get_aux_1(tmp_1_1,Map);
        int order2_1 = tmp_2_1;
        if (order1_1 < order2_1) {
          __retres_1 = -1;
          goto return_label_label_1;
        }
        else 
          if (order1_1 > order2_1) {
            __retres_1 = 1;
            goto return_label_label_1;
          }
          else {
            __retres_1 = 0;
            goto return_label_label_1;
          }
      }
    }
    __retres_1 = 0;
    return_label_label_1: return_variable_relational_1 = __retres_1;
  }
  {
    int __retres_2;
    int tmp_4_2;
    int tmp_3_2;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_2 = getID_aux_1(x2);
    }
    tmp_4_2 = containsKey_aux_1(tmp_3_2,Map);
    if (tmp_4_2) {
      int tmp_6_2;
      int tmp_5_2;
      ;
      tmp_5_2 = getID_aux_1(x1);
      tmp_6_2 = containsKey_aux_1(tmp_5_2,Map);
      if (tmp_6_2) {
        int tmp_0_2;
        int tmp_2;
        int tmp_2_2;
        int tmp_1_2;
        ;
        tmp_2 = getID_aux_1(x2);
        tmp_0_2 = get_aux_1(tmp_2,Map);
        int order1_2 = tmp_0_2;
        ;
        tmp_1_2 = getID_aux_1(x1);
        tmp_2_2 = get_aux_1(tmp_1_2,Map);
        int order2_2 = tmp_2_2;
        if (order1_2 < order2_2) {
          __retres_2 = -1;
          goto return_label_label_2;
        }
        else 
          if (order1_2 > order2_2) {
            __retres_2 = 1;
            goto return_label_label_2;
          }
          else {
            __retres_2 = 0;
            goto return_label_label_2;
          }
      }
    }
    __retres_2 = 0;
    return_label_label_2: return_variable_relational_2 = __retres_2;
  }
  /*@ assert
      Rpp: return_variable_relational_1 ≡ -return_variable_relational_2;
  */
  return;
}

int getID_aux_2(struct Node o1);

int containsKey_aux_2(int id, int *t);

int get_aux_2(int id, int *t);

/*@ requires \valid(Map + (0 .. 1000));
    requires \valid(Map + (0 .. 1000));
    requires \valid(Map + (0 .. 1000));
 */
void relational_wrapper_2(struct Node x1, struct Node x2, struct Node x3,
                          int *Map)
{
  int return_variable_relational_3;
  int return_variable_relational_4;
  int return_variable_relational_5;
  {
    int __retres_3;
    int tmp_4_3;
    int tmp_3_3;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_3 = getID_aux_2(x1);
    }
    tmp_4_3 = containsKey_aux_2(tmp_3_3,Map);
    if (tmp_4_3) {
      int tmp_6_3;
      int tmp_5_3;
      ;
      tmp_5_3 = getID_aux_2(x2);
      tmp_6_3 = containsKey_aux_2(tmp_5_3,Map);
      if (tmp_6_3) {
        int tmp_0_3;
        int tmp_3;
        int tmp_2_3;
        int tmp_1_3;
        ;
        tmp_3 = getID_aux_2(x1);
        tmp_0_3 = get_aux_2(tmp_3,Map);
        int order1_3 = tmp_0_3;
        ;
        tmp_1_3 = getID_aux_2(x2);
        tmp_2_3 = get_aux_2(tmp_1_3,Map);
        int order2_3 = tmp_2_3;
        if (order1_3 < order2_3) {
          __retres_3 = -1;
          goto return_label_label_3;
        }
        else 
          if (order1_3 > order2_3) {
            __retres_3 = 1;
            goto return_label_label_3;
          }
          else {
            __retres_3 = 0;
            goto return_label_label_3;
          }
      }
    }
    __retres_3 = 0;
    return_label_label_3: return_variable_relational_3 = __retres_3;
  }
  {
    int __retres_4;
    int tmp_4_4;
    int tmp_3_4;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_4 = getID_aux_2(x2);
    }
    tmp_4_4 = containsKey_aux_2(tmp_3_4,Map);
    if (tmp_4_4) {
      int tmp_6_4;
      int tmp_5_4;
      ;
      tmp_5_4 = getID_aux_2(x3);
      tmp_6_4 = containsKey_aux_2(tmp_5_4,Map);
      if (tmp_6_4) {
        int tmp_0_4;
        int tmp_4;
        int tmp_2_4;
        int tmp_1_4;
        ;
        tmp_4 = getID_aux_2(x2);
        tmp_0_4 = get_aux_2(tmp_4,Map);
        int order1_4 = tmp_0_4;
        ;
        tmp_1_4 = getID_aux_2(x3);
        tmp_2_4 = get_aux_2(tmp_1_4,Map);
        int order2_4 = tmp_2_4;
        if (order1_4 < order2_4) {
          __retres_4 = -1;
          goto return_label_label_4;
        }
        else 
          if (order1_4 > order2_4) {
            __retres_4 = 1;
            goto return_label_label_4;
          }
          else {
            __retres_4 = 0;
            goto return_label_label_4;
          }
      }
    }
    __retres_4 = 0;
    return_label_label_4: return_variable_relational_4 = __retres_4;
  }
  {
    int __retres_5;
    int tmp_4_5;
    int tmp_3_5;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_5 = getID_aux_2(x1);
    }
    tmp_4_5 = containsKey_aux_2(tmp_3_5,Map);
    if (tmp_4_5) {
      int tmp_6_5;
      int tmp_5_5;
      ;
      tmp_5_5 = getID_aux_2(x3);
      tmp_6_5 = containsKey_aux_2(tmp_5_5,Map);
      if (tmp_6_5) {
        int tmp_0_5;
        int tmp_5;
        int tmp_2_5;
        int tmp_1_5;
        ;
        tmp_5 = getID_aux_2(x1);
        tmp_0_5 = get_aux_2(tmp_5,Map);
        int order1_5 = tmp_0_5;
        ;
        tmp_1_5 = getID_aux_2(x3);
        tmp_2_5 = get_aux_2(tmp_1_5,Map);
        int order2_5 = tmp_2_5;
        if (order1_5 < order2_5) {
          __retres_5 = -1;
          goto return_label_label_5;
        }
        else 
          if (order1_5 > order2_5) {
            __retres_5 = 1;
            goto return_label_label_5;
          }
          else {
            __retres_5 = 0;
            goto return_label_label_5;
          }
      }
    }
    __retres_5 = 0;
    return_label_label_5: return_variable_relational_5 = __retres_5;
  }
  /*@ assert
      Rpp:
        return_variable_relational_3 > 0 ∧ return_variable_relational_4 > 0 ⇒
        return_variable_relational_5 > 0;
  */
  return;
}

int getID_aux_3(struct Node o1);

int containsKey_aux_3(int id, int *t);

int get_aux_3(int id, int *t);

/*@ requires \valid(Map + (0 .. 1000));
    requires \valid(Map + (0 .. 1000));
    requires \valid(Map + (0 .. 1000));
 */
void relational_wrapper_3(struct Node x1, struct Node x2, struct Node x3,
                          int *Map)
{
  int return_variable_relational_6;
  int return_variable_relational_7;
  int return_variable_relational_8;
  {
    int __retres_6;
    int tmp_4_6;
    int tmp_3_6;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_6 = getID_aux_3(x1);
    }
    tmp_4_6 = containsKey_aux_3(tmp_3_6,Map);
    if (tmp_4_6) {
      int tmp_6_6;
      int tmp_5_6;
      ;
      tmp_5_6 = getID_aux_3(x2);
      tmp_6_6 = containsKey_aux_3(tmp_5_6,Map);
      if (tmp_6_6) {
        int tmp_0_6;
        int tmp_6;
        int tmp_2_6;
        int tmp_1_6;
        ;
        tmp_6 = getID_aux_3(x1);
        tmp_0_6 = get_aux_3(tmp_6,Map);
        int order1_6 = tmp_0_6;
        ;
        tmp_1_6 = getID_aux_3(x2);
        tmp_2_6 = get_aux_3(tmp_1_6,Map);
        int order2_6 = tmp_2_6;
        if (order1_6 < order2_6) {
          __retres_6 = -1;
          goto return_label_label_6;
        }
        else 
          if (order1_6 > order2_6) {
            __retres_6 = 1;
            goto return_label_label_6;
          }
          else {
            __retres_6 = 0;
            goto return_label_label_6;
          }
      }
    }
    __retres_6 = 0;
    return_label_label_6: return_variable_relational_6 = __retres_6;
  }
  {
    int __retres_7;
    int tmp_4_7;
    int tmp_3_7;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_7 = getID_aux_3(x1);
    }
    tmp_4_7 = containsKey_aux_3(tmp_3_7,Map);
    if (tmp_4_7) {
      int tmp_6_7;
      int tmp_5_7;
      ;
      tmp_5_7 = getID_aux_3(x3);
      tmp_6_7 = containsKey_aux_3(tmp_5_7,Map);
      if (tmp_6_7) {
        int tmp_0_7;
        int tmp_7;
        int tmp_2_7;
        int tmp_1_7;
        ;
        tmp_7 = getID_aux_3(x1);
        tmp_0_7 = get_aux_3(tmp_7,Map);
        int order1_7 = tmp_0_7;
        ;
        tmp_1_7 = getID_aux_3(x3);
        tmp_2_7 = get_aux_3(tmp_1_7,Map);
        int order2_7 = tmp_2_7;
        if (order1_7 < order2_7) {
          __retres_7 = -1;
          goto return_label_label_7;
        }
        else 
          if (order1_7 > order2_7) {
            __retres_7 = 1;
            goto return_label_label_7;
          }
          else {
            __retres_7 = 0;
            goto return_label_label_7;
          }
      }
    }
    __retres_7 = 0;
    return_label_label_7: return_variable_relational_7 = __retres_7;
  }
  {
    int __retres_8;
    int tmp_4_8;
    int tmp_3_8;
    /*@ assert Rpp: \valid(Map + (0 .. 1000)); */
    {
      ;
      tmp_3_8 = getID_aux_3(x2);
    }
    tmp_4_8 = containsKey_aux_3(tmp_3_8,Map);
    if (tmp_4_8) {
      int tmp_6_8;
      int tmp_5_8;
      ;
      tmp_5_8 = getID_aux_3(x3);
      tmp_6_8 = containsKey_aux_3(tmp_5_8,Map);
      if (tmp_6_8) {
        int tmp_0_8;
        int tmp_8;
        int tmp_2_8;
        int tmp_1_8;
        ;
        tmp_8 = getID_aux_3(x2);
        tmp_0_8 = get_aux_3(tmp_8,Map);
        int order1_8 = tmp_0_8;
        ;
        tmp_1_8 = getID_aux_3(x3);
        tmp_2_8 = get_aux_3(tmp_1_8,Map);
        int order2_8 = tmp_2_8;
        if (order1_8 < order2_8) {
          __retres_8 = -1;
          goto return_label_label_8;
        }
        else 
          if (order1_8 > order2_8) {
            __retres_8 = 1;
            goto return_label_label_8;
          }
          else {
            __retres_8 = 0;
            goto return_label_label_8;
          }
      }
    }
    __retres_8 = 0;
    return_label_label_8: return_variable_relational_8 = __retres_8;
  }
  /*@ assert
      Rpp:
        return_variable_relational_6 ≡ 0 ⇒
        return_variable_relational_7 ≡ return_variable_relational_8;
  */
  return;
}

/*@ requires 0 ≤ id < 1000;
    ensures \result ≡ *(\old(t) + \old(id));
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int get_aux_3(int id, int *t);

/*@ requires 0 ≤ id < 1000;
    ensures *(\old(t) + \old(id)) ≢ -1 ⇒ \result ≡ 1;
    ensures *(\old(t) + \old(id)) ≡ -1 ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int containsKey_aux_3(int id, int *t);

/*@ ensures \result ≡ \old(o1.ID);
    ensures 0 ≤ \result < 1000;
    assigns \result;
    assigns \result \from o1;
 */
int getID_aux_3(struct Node o1);

/*@ requires 0 ≤ id < 1000;
    ensures \result ≡ *(\old(t) + \old(id));
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int get_aux_2(int id, int *t);

/*@ requires 0 ≤ id < 1000;
    ensures *(\old(t) + \old(id)) ≢ -1 ⇒ \result ≡ 1;
    ensures *(\old(t) + \old(id)) ≡ -1 ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int containsKey_aux_2(int id, int *t);

/*@ ensures \result ≡ \old(o1.ID);
    ensures 0 ≤ \result < 1000;
    assigns \result;
    assigns \result \from o1;
 */
int getID_aux_2(struct Node o1);

/*@ requires 0 ≤ id < 1000;
    ensures \result ≡ *(\old(t) + \old(id));
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int get_aux_1(int id, int *t);

/*@ requires 0 ≤ id < 1000;
    ensures *(\old(t) + \old(id)) ≢ -1 ⇒ \result ≡ 1;
    ensures *(\old(t) + \old(id)) ≡ -1 ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from id, *(t + (0 .. 1000));
 */
int containsKey_aux_1(int id, int *t);

/*@ ensures \result ≡ \old(o1.ID);
    ensures 0 ≤ \result < 1000;
    assigns \result;
    assigns \result \from o1;
 */
int getID_aux_1(struct Node o1);


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
