[kernel] Parsing benchmarks/stackoverflow/Time-false.c (with preprocessing)
[rpp] ***************************************
[rpp] Rpp start
[rpp] ***************************************
/* Generated by Frama-C */
struct Time {
   int ora ;
   int volume_totale ;
};
/*@ ensures \old(x) < \old(y) ⇒ \result ≡ -1;
    ensures \old(x) > \old(y) ⇒ \result ≡ 1;
    ensures \old(x) ≡ \old(y) ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from x, y;
 */
int IntCompare(int x, int y)
{
  int __retres;
  if (x < y) {
    __retres = -1;
    goto return_label;
  }
  if (x > y) {
    __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@
axiomatic Relational_axiome_3 {
  logic int compare_acsl_pure_3(struct Time o1, struct Time o2) ;
  
  lemma Relational_lemma_3{L}:
    ∀ struct Time x1, struct Time x2, struct Time x3;
      compare_acsl_pure_3(x1, x2) ≡ 0 ⇒
      compare_acsl_pure_3(x1, x3) ≡ compare_acsl_pure_3(x2, x3);
  
  }
 */
/*@
axiomatic Relational_axiome_2 {
  logic int compare_acsl_pure_2(struct Time o1, struct Time o2) ;
  
  lemma Relational_lemma_2{L}:
    ∀ struct Time x1, struct Time x2, struct Time x3;
      compare_acsl_pure_2(x1, x2) > 0 ∧ compare_acsl_pure_2(x2, x3) > 0 ⇒
      compare_acsl_pure_2(x1, x3) > 0;
  
  }
 */
/*@
axiomatic Relational_axiome_1 {
  logic int compare_acsl_pure_1(struct Time o1, struct Time o2) ;
  
  lemma Relational_lemma_1{L}:
    ∀ struct Time x1, struct Time x2;
      compare_acsl_pure_1(x1, x2) ≡ -compare_acsl_pure_1(x2, x1);
  
  }

*/
/*@ assigns \result;
    assigns \result \from o1, o2;
    
    behavior Relational_behavior_1:
      ensures \result ≡ compare_acsl_pure_1(\old(o1), \old(o2));
    
    behavior Relational_behavior_2:
      ensures \result ≡ compare_acsl_pure_2(\old(o1), \old(o2));
    
    behavior Relational_behavior_3:
      ensures \result ≡ compare_acsl_pure_3(\old(o1), \old(o2));
 */
int compare(struct Time o1, struct Time o2)
{
  int __retres;
  int tmp_1;
  int time1 = o1.ora;
  int time2 = o2.ora;
  tmp_1 = IntCompare(time1,time2);
  if (tmp_1 == 0) {
    int tmp;
    int voltot1 = o1.volume_totale;
    int voltot2 = o2.volume_totale;
    tmp = IntCompare(voltot1,voltot2);
    if (tmp > 0) {
      __retres = 1;
      goto return_label;
    }
    else {
      __retres = -1;
      goto return_label;
    }
  }
  else {
    int tmp_0;
    tmp_0 = IntCompare(time1,time2);
    __retres = tmp_0;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ ensures \old(x) < \old(y) ⇒ \result ≡ -1;
    ensures \old(x) > \old(y) ⇒ \result ≡ 1;
    ensures \old(x) ≡ \old(y) ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from x, y;
 */
int IntCompare_aux_3(int x, int y);

/*@ ensures \old(x) < \old(y) ⇒ \result ≡ -1;
    ensures \old(x) > \old(y) ⇒ \result ≡ 1;
    ensures \old(x) ≡ \old(y) ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from x, y;
 */
int IntCompare_aux_2(int x, int y);

/*@ ensures \old(x) < \old(y) ⇒ \result ≡ -1;
    ensures \old(x) > \old(y) ⇒ \result ≡ 1;
    ensures \old(x) ≡ \old(y) ⇒ \result ≡ 0;
    assigns \result;
    assigns \result \from x, y;
 */
int IntCompare_aux_1(int x, int y);

void relational_wrapper_1(struct Time x1, struct Time x2)
{
  int return_variable_relational_1;
  int return_variable_relational_2;
  {
    int __retres_1;
    int tmp_1_1;
    int time1_1 = x1.ora;
    int time2_1 = x2.ora;
    tmp_1_1 = IntCompare_aux_1(time1_1,time2_1);
    if (tmp_1_1 == 0) {
      int tmp_1;
      int voltot1_1 = x1.volume_totale;
      int voltot2_1 = x2.volume_totale;
      tmp_1 = IntCompare_aux_1(voltot1_1,voltot2_1);
      if (tmp_1 > 0) {
        __retres_1 = 1;
        goto return_label_label_1;
      }
      else {
        __retres_1 = -1;
        goto return_label_label_1;
      }
    }
    else {
      int tmp_0_1;
      tmp_0_1 = IntCompare_aux_1(time1_1,time2_1);
      __retres_1 = tmp_0_1;
      goto return_label_label_1;
    }
    return_label_label_1: return_variable_relational_1 = __retres_1;
  }
  {
    int __retres_2;
    int tmp_1_2;
    int time1_2 = x2.ora;
    int time2_2 = x1.ora;
    tmp_1_2 = IntCompare_aux_1(time1_2,time2_2);
    if (tmp_1_2 == 0) {
      int tmp_2;
      int voltot1_2 = x2.volume_totale;
      int voltot2_2 = x1.volume_totale;
      tmp_2 = IntCompare_aux_1(voltot1_2,voltot2_2);
      if (tmp_2 > 0) {
        __retres_2 = 1;
        goto return_label_label_2;
      }
      else {
        __retres_2 = -1;
        goto return_label_label_2;
      }
    }
    else {
      int tmp_0_2;
      tmp_0_2 = IntCompare_aux_1(time1_2,time2_2);
      __retres_2 = tmp_0_2;
      goto return_label_label_2;
    }
    return_label_label_2: return_variable_relational_2 = __retres_2;
  }
  /*@ check
      Rpp: return_variable_relational_1 ≡ -return_variable_relational_2;
  */
  return;
}

void relational_wrapper_2(struct Time x1, struct Time x2, struct Time x3)
{
  int return_variable_relational_3;
  int return_variable_relational_4;
  int return_variable_relational_5;
  {
    int __retres_3;
    int tmp_1_3;
    int time1_3 = x1.ora;
    int time2_3 = x2.ora;
    tmp_1_3 = IntCompare_aux_2(time1_3,time2_3);
    if (tmp_1_3 == 0) {
      int tmp_3;
      int voltot1_3 = x1.volume_totale;
      int voltot2_3 = x2.volume_totale;
      tmp_3 = IntCompare_aux_2(voltot1_3,voltot2_3);
      if (tmp_3 > 0) {
        __retres_3 = 1;
        goto return_label_label_3;
      }
      else {
        __retres_3 = -1;
        goto return_label_label_3;
      }
    }
    else {
      int tmp_0_3;
      tmp_0_3 = IntCompare_aux_2(time1_3,time2_3);
      __retres_3 = tmp_0_3;
      goto return_label_label_3;
    }
    return_label_label_3: return_variable_relational_3 = __retres_3;
  }
  {
    int __retres_4;
    int tmp_1_4;
    int time1_4 = x2.ora;
    int time2_4 = x3.ora;
    tmp_1_4 = IntCompare_aux_2(time1_4,time2_4);
    if (tmp_1_4 == 0) {
      int tmp_4;
      int voltot1_4 = x2.volume_totale;
      int voltot2_4 = x3.volume_totale;
      tmp_4 = IntCompare_aux_2(voltot1_4,voltot2_4);
      if (tmp_4 > 0) {
        __retres_4 = 1;
        goto return_label_label_4;
      }
      else {
        __retres_4 = -1;
        goto return_label_label_4;
      }
    }
    else {
      int tmp_0_4;
      tmp_0_4 = IntCompare_aux_2(time1_4,time2_4);
      __retres_4 = tmp_0_4;
      goto return_label_label_4;
    }
    return_label_label_4: return_variable_relational_4 = __retres_4;
  }
  {
    int __retres_5;
    int tmp_1_5;
    int time1_5 = x1.ora;
    int time2_5 = x3.ora;
    tmp_1_5 = IntCompare_aux_2(time1_5,time2_5);
    if (tmp_1_5 == 0) {
      int tmp_5;
      int voltot1_5 = x1.volume_totale;
      int voltot2_5 = x3.volume_totale;
      tmp_5 = IntCompare_aux_2(voltot1_5,voltot2_5);
      if (tmp_5 > 0) {
        __retres_5 = 1;
        goto return_label_label_5;
      }
      else {
        __retres_5 = -1;
        goto return_label_label_5;
      }
    }
    else {
      int tmp_0_5;
      tmp_0_5 = IntCompare_aux_2(time1_5,time2_5);
      __retres_5 = tmp_0_5;
      goto return_label_label_5;
    }
    return_label_label_5: return_variable_relational_5 = __retres_5;
  }
  /*@ check
      Rpp:
        return_variable_relational_3 > 0 ∧ return_variable_relational_4 > 0 ⇒
        return_variable_relational_5 > 0;
  */
  return;
}

void relational_wrapper_3(struct Time x1, struct Time x2, struct Time x3)
{
  int return_variable_relational_6;
  int return_variable_relational_7;
  int return_variable_relational_8;
  {
    int __retres_6;
    int tmp_1_6;
    int time1_6 = x1.ora;
    int time2_6 = x2.ora;
    tmp_1_6 = IntCompare_aux_3(time1_6,time2_6);
    if (tmp_1_6 == 0) {
      int tmp_6;
      int voltot1_6 = x1.volume_totale;
      int voltot2_6 = x2.volume_totale;
      tmp_6 = IntCompare_aux_3(voltot1_6,voltot2_6);
      if (tmp_6 > 0) {
        __retres_6 = 1;
        goto return_label_label_6;
      }
      else {
        __retres_6 = -1;
        goto return_label_label_6;
      }
    }
    else {
      int tmp_0_6;
      tmp_0_6 = IntCompare_aux_3(time1_6,time2_6);
      __retres_6 = tmp_0_6;
      goto return_label_label_6;
    }
    return_label_label_6: return_variable_relational_6 = __retres_6;
  }
  {
    int __retres_7;
    int tmp_1_7;
    int time1_7 = x1.ora;
    int time2_7 = x3.ora;
    tmp_1_7 = IntCompare_aux_3(time1_7,time2_7);
    if (tmp_1_7 == 0) {
      int tmp_7;
      int voltot1_7 = x1.volume_totale;
      int voltot2_7 = x3.volume_totale;
      tmp_7 = IntCompare_aux_3(voltot1_7,voltot2_7);
      if (tmp_7 > 0) {
        __retres_7 = 1;
        goto return_label_label_7;
      }
      else {
        __retres_7 = -1;
        goto return_label_label_7;
      }
    }
    else {
      int tmp_0_7;
      tmp_0_7 = IntCompare_aux_3(time1_7,time2_7);
      __retres_7 = tmp_0_7;
      goto return_label_label_7;
    }
    return_label_label_7: return_variable_relational_7 = __retres_7;
  }
  {
    int __retres_8;
    int tmp_1_8;
    int time1_8 = x2.ora;
    int time2_8 = x3.ora;
    tmp_1_8 = IntCompare_aux_3(time1_8,time2_8);
    if (tmp_1_8 == 0) {
      int tmp_8;
      int voltot1_8 = x2.volume_totale;
      int voltot2_8 = x3.volume_totale;
      tmp_8 = IntCompare_aux_3(voltot1_8,voltot2_8);
      if (tmp_8 > 0) {
        __retres_8 = 1;
        goto return_label_label_8;
      }
      else {
        __retres_8 = -1;
        goto return_label_label_8;
      }
    }
    else {
      int tmp_0_8;
      tmp_0_8 = IntCompare_aux_3(time1_8,time2_8);
      __retres_8 = tmp_0_8;
      goto return_label_label_8;
    }
    return_label_label_8: return_variable_relational_8 = __retres_8;
  }
  /*@ check
      Rpp:
        return_variable_relational_6 ≡ 0 ⇒
        return_variable_relational_7 ≡ return_variable_relational_8;
  */
  return;
}


[rpp] ***************************************
[rpp] Rpp end
[rpp] ***************************************
